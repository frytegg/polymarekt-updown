/**
 * Backtest Types for Crypto Pricer Arb
 */

// =============================================================================
// DATA FETCHER TYPES
// =============================================================================

/**
 * Price point from Binance klines
 */
export interface BinanceKline {
    timestamp: number;      // Unix ms
    open: number;
    high: number;
    low: number;
    close: number;
    volume: number;
}

/**
 * Price point from Polymarket /prices-history API
 */
export interface PolymarketPricePoint {
    timestamp: number;      // Unix ms
    price: number;          // 0-1
}

/**
 * Historical market from Polymarket Gamma API
 */
export interface HistoricalMarket {
    conditionId: string;
    question: string;
    slug: string;
    tokenIds: [string, string];  // [YES, NO]
    outcomes: [string, string];  // ["Up", "Down"]
    strikePrice: number;         // BTC price at start
    startTime: number;           // Unix ms - when 15min period starts
    endTime: number;             // Unix ms - when 15min period ends
    resolved: boolean;
    outcome?: 'UP' | 'DOWN';     // Resolution outcome
}

/**
 * Volatility data point from Deribit
 */
export interface DeribitVolPoint {
    timestamp: number;      // Unix ms
    vol: number;            // Annualized vol as decimal (e.g., 0.48 for 48%)
}

// =============================================================================
// BACKTEST ENGINE TYPES
// =============================================================================

/**
 * Aligned tick with all data sources synchronized
 */
export interface AlignedTick {
    timestamp: number;
    btcPrice: number;           // From Binance (close price)
    btcKline?: BinanceKline;    // Full kline for worst-case simulation
    polyMidYes: number;         // Polymarket YES mid price
    polyMidNo: number;          // Polymarket NO mid price (usually 1 - YES)
    vol: number;                // Blended vol: 70% realized 1h + 20% realized 4h + 10% DVOL
    timeRemainingMs: number;    // Time until market resolution
}

/**
 * Fair value calculation result
 */
export interface FairValue {
    pUp: number;        // Probability of UP (0-1)
    pDown: number;      // Probability of DOWN (0-1)
    d: number;          // d₂ value from Black-Scholes
    sigmaT: number;     // σ√τ
}

/**
 * Trade signal generated by the strategy
 */
export interface TradeSignal {
    timestamp: number;
    marketId: string;
    side: 'YES' | 'NO';
    fairValue: number;
    marketPrice: number;
    edge: number;
    size: number;
}

/**
 * Executed trade record
 */
export interface Trade {
    id: string;
    timestamp: number;
    marketId: string;
    side: 'YES' | 'NO';
    action: 'BUY' | 'SELL';
    price: number;
    size: number;
    fairValue: number;
    edge: number;
    btcPrice: number;
    strike: number;
    timeRemainingMs: number;
    cost: number;              // price * size (without fee)
    fee: number;               // Polymarket taker fee
    totalCost: number;         // cost + fee (what you actually pay)
}

/**
 * Position in a single market
 */
export interface MarketPosition {
    marketId: string;
    yesShares: number;
    noShares: number;
    yesCost: number;           // Total cost basis for YES
    noCost: number;            // Total cost basis for NO
    trades: Trade[];
}

/**
 * Resolution result for a market
 */
export interface MarketResolution {
    marketId: string;
    outcome: 'UP' | 'DOWN';
    finalBtcPrice: number;
    strikePrice: number;
    yesShares: number;
    noShares: number;
    yesCost: number;
    noCost: number;
    yesPayout: number;         // yesShares * (outcome === 'UP' ? 1 : 0)
    noPayout: number;          // noShares * (outcome === 'DOWN' ? 1 : 0)
    totalPayout: number;
    totalCost: number;
    pnl: number;               // totalPayout - totalCost
}

// =============================================================================
// BACKTEST CONFIG & RESULTS
// =============================================================================

/**
 * Backtest mode for easy switching between configurations
 * - 'normal': Use close price, no latency (optimistic simulation)
 * - 'conservative': Use worst-case pricing (kline low/high), 200ms latency
 */
export type BacktestMode = 'normal' | 'conservative';

/**
 * Adjustment method for Binance→Chainlink price correction
 * - 'static': Use fixed adjustment value (binanceChainlinkAdjustment)
 * - 'rolling-mean': Rolling mean of divergence over window
 * - 'ema': Exponential moving average of divergence
 * - 'median': Rolling median (robust to outliers)
 */
export type AdjustmentMethod = 'static' | 'rolling-mean' | 'ema' | 'median';

/**
 * Backtest configuration
 */
export interface BacktestConfig {
    startDate: Date;
    endDate: Date;
    initialCapital: number;    // Infinity for unlimited
    spreadCents: number;       // Spread to apply on mid price (default 1¢)
    minEdge: number;           // Minimum edge to trade (e.g., 0.02 = 2%)
    orderSize: number;         // Shares per order
    maxPositionPerMarket: number;  // Max shares per side per market
    lagSeconds: number;        // Lag between BTC price observation and Polymarket execution (default 0)
    executionLatencyMs: number;    // Simulated execution delay in ms (default: 0)
    useChainlinkForFairValue: boolean;  // Use Chainlink instead of Binance for fair value calculation
    volMultiplier: number;     // Multiplier for short-term vol adjustment (default: 1.0)
    mode: BacktestMode;        // Easy toggle: 'normal' or 'conservative'
    binanceChainlinkAdjustment: number;  // Adjustment to apply to Binance prices for fair value (default: 0)
                                         // Set to -104 to correct for Chainlink being ~$104 lower than Binance
    adjustmentMethod: AdjustmentMethod;  // Method for calculating adjustment (default: 'static')
    adjustmentWindowHours: number;       // Rolling window size in hours for adaptive methods (default: 2)
    includeFees: boolean;      // Include Polymarket taker fees (15-min crypto markets)
    cooldownMs: number;        // Minimum ms between trades per market+side (default: 60000)
    maxTradesPerMarket: number; // Max total trades per market across both sides (default: 3)
    maxOrderUsd: number;       // Max USD per order (default: Infinity = share-based only)
    maxPositionUsd: number;    // Max USD per market position (default: Infinity = share-based only)
}

/**
 * Backtest result summary
 */
export interface BacktestResult {
    config: BacktestConfig;

    // Summary stats
    totalMarkets: number;
    totalTrades: number;
    totalPnL: number;
    totalVolume: number;       // Sum of all trade sizes * prices

    // Fee statistics
    totalFeesPaid: number;     // Total Polymarket taker fees paid
    avgFeePerTrade: number;    // Average fee per trade
    avgFeeRate: number;        // Average fee as percentage of trade cost

    // Performance metrics
    winRate: number;           // % of profitable trades
    marketWinRate: number;     // % of profitable markets
    avgEdge: number;           // Average edge at time of trade
    realizedEdge: number;      // Actual realized edge
    sharpeRatio: number;
    maxDrawdown: number;

    // Capital metrics (only meaningful when initialCapital !== Infinity)
    initialCapital: number;        // Starting capital
    finalCapital: number;          // initialCapital + totalPnL
    peakDeployedCapital: number;   // Maximum capital deployed at any point
    capitalUtilization: number;    // peakDeployed / initial (as ratio, e.g., 0.385 = 38.5%)

    // Detailed data
    trades: Trade[];
    resolutions: MarketResolution[];
    pnlCurve: PnLPoint[];
}

/**
 * P&L curve point
 */
export interface PnLPoint {
    timestamp: number;
    cumulativePnL: number;
    unrealizedPnL: number;
    realizedPnL: number;
}

/**
 * Statistics summary
 */
export interface Statistics {
    // Overall
    totalPnL: number;
    totalTrades: number;
    totalMarkets: number;
    totalStaked: number;        // Sum of all trade costs (price * size)
    winningTrades: number;
    losingTrades: number;
    winRate: number;

    // Fee statistics
    totalFeesPaid: number;      // Total Polymarket taker fees paid
    avgFeePerTrade: number;     // Average fee per trade
    avgFeeRate: number;         // Average fee as percentage of trade cost

    // By side
    yesTrades: number;
    noTrades: number;
    yesPnL: number;
    noPnL: number;

    // Edge analysis
    avgEdgeAtTrade: number;
    avgRealizedEdge: number;    // totalPnL / totalStaked (real ROI)
    edgeCapture: number;        // realizedEdge / expectedEdge
    
    // Per-trade edge breakdown
    avgExpectedReturnPerShare: number;   // avg (fairValue - price) per share
    avgRealizedReturnPerShare: number;   // avg (payout - price) per share
    
    // By outcome
    winningTradesAvgEdge: number;        // avg expected edge on winning trades
    winningTradesAvgReturn: number;      // avg realized return on winning trades  
    losingTradesAvgEdge: number;         // avg expected edge on losing trades
    losingTradesAvgReturn: number;       // avg realized return on losing trades
    
    // Model calibration
    avgFairValueOnWins: number;          // how confident were we on wins?
    avgFairValueOnLosses: number;        // how confident were we on losses?

    // Risk metrics
    sharpeRatio: number;
    sortinoRatio: number;
    profitFactor: number;         // gross profit / gross loss
    maxDrawdown: number;
    maxDrawdownDuration: number;  // in ms

    // Per market
    avgPnLPerMarket: number;
    avgTradesPerMarket: number;
    profitableMarkets: number;
    unprofitableMarkets: number;
}

// =============================================================================
// CACHE TYPES
// =============================================================================

/**
 * Cache metadata for a data file
 */
export interface CacheMetadata {
    source: 'binance' | 'polymarket' | 'deribit' | 'chainlink';
    startTs: number;
    endTs: number;
    symbol?: string;
    tokenId?: string;
    fetchedAt: number;
}

/**
 * Cached data file structure
 */
export interface CachedData<T> {
    metadata: CacheMetadata;
    data: T[];
}

